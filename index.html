<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLYPH & GOOSE Pub Crawl Planner</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;

        function PubCrawlPlanner() {
          const [pubs, setPubs] = useState([]);
          const [sortBy, setSortBy] = useState('letter');
          const [filterLetter, setFilterLetter] = useState('all');
          const [routes, setRoutes] = useState([]);
          const [statusMessage, setStatusMessage] = useState('');
          const [debugLog, setDebugLog] = useState([]);
          const [homeLocation, setHomeLocation] = useState({ lat: 51.4817, lon: -0.1130 });
          const [startingArea, setStartingArea] = useState('any');
          const [startingPub, setStartingPub] = useState(null);

          const getFirstLetter = (name) => {
            const cleanName = name.replace(/^the\s+/i, '');
            return cleanName.charAt(0).toUpperCase();
          };

          const processGeoJSON = (geojson) => {
            const features = geojson.features || [];
            const processed = [];

            features.forEach(feature => {
              const props = feature.properties || {};
              const geometry = feature.geometry;
              
              if (props.amenity === 'pub' && props.name && geometry) {
                const firstLetter = getFirstLetter(props.name);
                
                if (['G', 'L', 'Y', 'P', 'H', 'O', 'S', 'E'].includes(firstLetter)) {
                  let lat, lon;
                  
                  if (geometry.type === 'Point') {
                    lon = geometry.coordinates[0];
                    lat = geometry.coordinates[1];
                  } else if (geometry.type === 'Polygon' || geometry.type === 'LineString') {
                    const coords = geometry.type === 'Polygon' ? geometry.coordinates[0] : geometry.coordinates;
                    let sumLat = 0, sumLon = 0;
                    coords.forEach(coord => {
                      sumLon += coord[0];
                      sumLat += coord[1];
                    });
                    lon = sumLon / coords.length;
                    lat = sumLat / coords.length;
                  } else {
                    return;
                  }
                  
                  if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                    processed.push({
                      name: props.name,
                      firstLetter: firstLetter,
                      lat: lat,
                      lon: lon,
                      address: props['addr:street'] || 'N/A',
                      city: props['addr:city'] || 'N/A'
                    });
                  }
                }
              }
            });

            return processed;
          };

          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const geojson = JSON.parse(e.target.result);
                const processed = processGeoJSON(geojson);
                setPubs(processed);
                setRoutes([]);
                setStatusMessage(`Loaded ${processed.length} pubs`);
                setDebugLog([]);
              } catch (error) {
                alert('Error parsing GeoJSON file: ' + error.message);
              }
            };
            reader.readAsText(file);
          };

          const calculateDistance = (lat1, lon1, lat2, lon2) => {
            if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) {
              return NaN;
            }
            if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || 
                typeof lat2 !== 'number' || typeof lon2 !== 'number') {
              return NaN;
            }
            
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
              Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
          };

          const generateRouteForward = (startPub, endPub, allPubs, variation = 0) => {
            const sequence = ['G', 'L', 'Y', 'P', 'H', 'G', 'O', 'O', 'S', 'E'];
            const route = [{ pub: startPub, distance: 0, letter: 'G' }];
            const usedPubIds = new Set([startPub.name + startPub.lat]);
            
            let currentLat = startPub.lat;
            let currentLon = startPub.lon;
            let totalDistance = 0;

            for (let i = 1; i < sequence.length; i++) {
              const targetLetter = sequence[i];
              
              if (i === sequence.length - 1) {
                const finalDist = calculateDistance(currentLat, currentLon, endPub.lat, endPub.lon);
                route.push({
                  pub: endPub,
                  distance: finalDist,
                  letter: 'E'
                });
                totalDistance += finalDist;
                break;
              }
              
              const candidates = allPubs.filter(p => 
                p.firstLetter === targetLetter && 
                !usedPubIds.has(p.name + p.lat) &&
                p.lat != null &&
                p.lon != null
              );
              
              if (candidates.length === 0) return null;
              
              const scoredCandidates = [];
              
              for (const pub of candidates) {
                const pubLat = typeof pub.lat === 'number' ? pub.lat : parseFloat(pub.lat);
                const pubLon = typeof pub.lon === 'number' ? pub.lon : parseFloat(pub.lon);
                
                if (isNaN(pubLat) || isNaN(pubLon)) continue;
                
                const distFromCurrent = calculateDistance(currentLat, currentLon, pubLat, pubLon);
                const distToEnd = calculateDistance(pubLat, pubLon, endPub.lat, endPub.lon);
                
                if (isNaN(distFromCurrent) || isNaN(distToEnd)) continue;
                
                let score;
                
                if (i === sequence.length - 2) {
                  if (distToEnd > 1.0) {
                    const penalty = (distToEnd - 1.0) * 5;
                    score = (distFromCurrent * 0.3) + (distToEnd * 0.7) + penalty;
                  } else {
                    score = (distFromCurrent * 0.4) + (distToEnd * 0.6);
                  }
                } else {
                  const progressWeight = 0.3 + (i / sequence.length * 0.3);
                  const nearWeight = 1 - progressWeight;
                  score = (distFromCurrent * nearWeight) + (distToEnd * progressWeight);
                }
                
                scoredCandidates.push({ pub, score });
              }
              
              if (scoredCandidates.length === 0) return null;
              
              scoredCandidates.sort((a, b) => a.score - b.score);
              
              let selectedPub;
              if (variation === 0) {
                selectedPub = scoredCandidates[0].pub;
              } else {
                const topN = Math.min(5, scoredCandidates.length);
                const index = (variation - 1) % topN;
                selectedPub = scoredCandidates[index].pub;
              }
              
              const stepDist = calculateDistance(currentLat, currentLon, selectedPub.lat, selectedPub.lon);
              
              route.push({
                pub: selectedPub,
                distance: stepDist,
                letter: targetLetter
              });
              
              usedPubIds.add(selectedPub.name + selectedPub.lat);
              currentLat = selectedPub.lat;
              currentLon = selectedPub.lon;
              totalDistance += stepDist;
            }

            return { route, totalDistance };
          };

          const calculateOptimalRoutes = () => {
            try {
              setStatusMessage('Starting calculation...');
              setDebugLog([]);
              
              const ePubs = pubs.filter(p => p.firstLetter === 'E');
              
              if (ePubs.length === 0) {
                setStatusMessage('ERROR: No pubs starting with E found!');
                return;
              }
              
              ePubs.sort((a, b) => {
                const distA = calculateDistance(a.lat, a.lon, homeLocation.lat, homeLocation.lon);
                const distB = calculateDistance(b.lat, b.lon, homeLocation.lat, homeLocation.lon);
                return distA - distB;
              });
              
              const closestEPub = ePubs[0];
              const closestEDist = calculateDistance(closestEPub.lat, closestEPub.lon, homeLocation.lat, homeLocation.lon);
              
              setStatusMessage(`Found ${ePubs.length} E pubs. Using closest to Oval as endpoint...`);
              setDebugLog([
                `Closest E pub to Oval: ${closestEPub.name} (${closestEDist.toFixed(2)}km away)`,
                `All routes will end at this pub`
              ]);
              
              const letterCounts = {};
              pubs.forEach(p => {
                letterCounts[p.firstLetter] = (letterCounts[p.firstLetter] || 0) + 1;
              });
              
              const needed = { G: 2, L: 1, Y: 1, P: 1, H: 1, O: 2, S: 1, E: 1 };
              const missing = [];
              for (const [letter, count] of Object.entries(needed)) {
                if (!letterCounts[letter] || letterCounts[letter] < count) {
                  missing.push(`${letter} (need ${count}, have ${letterCounts[letter] || 0})`);
                }
              }
              
              if (missing.length > 0) {
                setStatusMessage(`ERROR: Missing letters: ${missing.join(', ')}`);
                return;
              }
              
              let gPubs = pubs.filter(p => p.firstLetter === 'G');
              
              if (startingPub) {
                gPubs = [startingPub];
                setStatusMessage(`Finding routes from ${startingPub.name} to ${closestEPub.name}...`);
                setDebugLog(prev => [...prev, `Generating multiple route variations from ${startingPub.name}...`]);
              } else if (startingArea !== 'any') {
                const areaCoords = {
                  soho: { lat: 51.5136, lon: -0.1358 },
                  coventGarden: { lat: 51.5117, lon: -0.1232 },
                  shoreditch: { lat: 51.5251, lon: -0.0823 },
                  camden: { lat: 51.5392, lon: -0.1426 },
                  southBank: { lat: 51.5074, lon: -0.1198 }
                };
                
                const areaCenter = areaCoords[startingArea];
                if (areaCenter) {
                  gPubs = gPubs.filter(g => {
                    const dist = calculateDistance(g.lat, g.lon, areaCenter.lat, areaCenter.lon);
                    return dist <= 1.5;
                  }).sort((a, b) => {
                    const distA = calculateDistance(a.lat, a.lon, areaCenter.lat, areaCenter.lon);
                    const distB = calculateDistance(b.lat, b.lon, areaCenter.lat, areaCenter.lon);
                    return distA - distB;
                  });
                  
                  setStatusMessage(`Finding routes from ${startingArea} to ${closestEPub.name}...`);
                  setDebugLog(prev => [...prev, `Found ${gPubs.length} G pubs in ${startingArea}`]);
                }
              } else {
                setStatusMessage(`Finding best routes ending at ${closestEPub.name}...`);
              }
              
              if (gPubs.length === 0) {
                setStatusMessage('ERROR: No suitable starting pubs found in selected area!');
                return;
              }
              
              const allRoutes = [];
              const maxToTest = startingPub ? 1 : Math.min(30, gPubs.length);
              
              setDebugLog(prev => [...prev, `Testing ${maxToTest} starting points (routes will move towards Oval)...`]);
              
              if (startingPub) {
                for (let v = 0; v < 20; v++) {
                  const route = generateRouteForward(startingPub, closestEPub, pubs, v);
                  if (route) {
                    route.distanceToHome = closestEDist;
                    route.endPubName = closestEPub.name;
                    route.startPubName = startingPub.name;
                    route.variation = v;
                    allRoutes.push(route);
                  }
                }
                setDebugLog(prev => [...prev, `Generated ${allRoutes.length} different routes from ${startingPub.name}`]);
              } else {
                for (let i = 0; i < maxToTest; i++) {
                  const route = generateRouteForward(gPubs[i], closestEPub, pubs, 0);
                  if (route) {
                    route.distanceToHome = closestEDist;
                    route.endPubName = closestEPub.name;
                    route.startPubName = gPubs[i].name;
                    allRoutes.push(route);
                  }
                  
                  if (i % 10 === 0 && i > 0) {
                    setDebugLog(prev => [...prev, `Processed ${i} starting points, found ${allRoutes.length} routes...`]);
                  }
                }
              }
              
              if (allRoutes.length === 0) {
                setStatusMessage('ERROR: Could not generate any valid routes!');
                return;
              }
              
              allRoutes.sort((a, b) => a.totalDistance - b.totalDistance);
              
              const topRoutes = allRoutes.slice(0, 10);
              setRoutes(topRoutes);
              
              setDebugLog(prev => [...prev, 
                `‚úÖ Complete! All routes end at ${closestEPub.name} (${closestEDist.toFixed(2)}km from Oval)`,
                `Shortest route: ${topRoutes[0].totalDistance.toFixed(2)}km from ${topRoutes[0].startPubName}`
              ]);
              setStatusMessage(`SUCCESS! Top ${topRoutes.length} routes, all ending at ${closestEPub.name}.`);
            } catch (error) {
              setStatusMessage(`ERROR: ${error.message}`);
              setDebugLog(prev => [...prev, `Exception: ${error.message}`]);
            }
          };

          const getSortedPubs = () => {
            let filtered = filterLetter === 'all' 
              ? pubs 
              : pubs.filter(p => p.firstLetter === filterLetter);

            return [...filtered].sort((a, b) => {
              if (sortBy === 'letter') {
                return a.firstLetter.localeCompare(b.firstLetter) || a.name.localeCompare(b.name);
              } else {
                return a.name.localeCompare(b.name);
              }
            });
          };

          const downloadCSV = () => {
            const sorted = getSortedPubs();
            const headers = ['Pub Name', 'First Letter', 'Latitude', 'Longitude', 'Address', 'City'];
            const rows = sorted.map(pub => [
              `"${pub.name}"`,
              pub.firstLetter,
              pub.lat,
              pub.lon,
              `"${pub.address}"`,
              `"${pub.city}"`
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pub-crawl-data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
          };

          const downloadRouteCSV = (route, routeIndex) => {
            const headers = ['Stop', 'Letter', 'Pub Name', 'Distance from Previous (km)', 'Latitude', 'Longitude', 'Address'];
            const rows = route.route.map((stop, idx) => [
              idx + 1,
              stop.letter,
              `"${stop.pub.name}"`,
              stop.distance.toFixed(2),
              stop.pub.lat,
              stop.pub.lon,
              `"${stop.pub.address}"`
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route-${routeIndex + 1}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
          };

          const openInGoogleMaps = (route) => {
            const stops = route.route.map(stop => 
              `${stop.pub.lat},${stop.pub.lon}`
            );
            
            if (stops.length > 10) {
              alert(`Google Maps supports a maximum of 10 stops. This route has ${stops.length} stops. Opening first 10 stops only.`);
            }
            
            const limitedStops = stops.slice(0, 10);
            const mapsUrl = `https://www.google.com/maps/dir/${limitedStops.join('/')}`;
            window.open(mapsUrl, '_blank');
          };

          const getLetterCounts = () => {
            const counts = {};
            pubs.forEach(pub => {
              counts[pub.firstLetter] = (counts[pub.firstLetter] || 0) + 1;
            });
            return counts;
          };

          const letterCounts = getLetterCounts();
          const sortedPubs = getSortedPubs();
          const targetLetters = ['G', 'L', 'Y', 'P', 'H', 'G', 'O', 'O', 'S', 'E'];

          // Lucide React icons as SVG
          const MapPinIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
          );

          const UploadIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
          );

          const ZapIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
            </svg>
          );

          const NavigationIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>
            </svg>
          );

          const DownloadIcon = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          );

          return (
            <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-8">
              <div className="max-w-6xl mx-auto">
                <div className="bg-gray-800 rounded-lg shadow-2xl p-8 border border-gray-700">
                  <h1 className="text-3xl font-bold text-amber-400 mb-2 flex items-center gap-2">
                    <MapPinIcon />
                    GLYPH & GOOSE Pub Crawl Planner
                  </h1>
                  <p className="text-gray-400 mb-6">Upload your pub data to plan your optimal pub crawl route</p>

                  <div className="mb-6">
                    <label className="flex items-center justify-center w-full px-4 py-6 bg-gray-700 border-2 border-dashed border-amber-600 rounded-lg cursor-pointer hover:bg-gray-600 transition">
                      <UploadIcon />
                      <span className="text-amber-400 font-medium ml-2">Upload GeoJSON File</span>
                      <input type="file" accept=".json,.geojson" onChange={handleFileUpload} className="hidden" />
                    </label>
                  </div>

                  {pubs.length > 0 && (
                    <>
                      <div className="mb-6 p-4 bg-gray-700 rounded-lg border border-gray-600">
                        <h3 className="font-semibold text-amber-400 mb-3">Starting Location Options:</h3>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                          <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Choose Starting Area:</label>
                            <select 
                              value={startingArea} 
                              onChange={(e) => {
                                setStartingArea(e.target.value);
                                setStartingPub(null);
                              }}
                              className="w-full px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg text-gray-100"
                            >
                              <option value="any">Any Location</option>
                              <option value="soho">Soho</option>
                              <option value="coventGarden">Covent Garden</option>
                              <option value="shoreditch">Shoreditch</option>
                              <option value="camden">Camden</option>
                              <option value="southBank">South Bank</option>
                            </select>
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Or Pick Specific Pub:</label>
                            <select 
                              value={startingPub ? startingPub.name : ''} 
                              onChange={(e) => {
                                const pub = pubs.find(p => p.name === e.target.value && p.firstLetter === 'G');
                                setStartingPub(pub || null);
                                if (pub) setStartingArea('any');
                              }}
                              className="w-full px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg text-gray-100"
                            >
                              <option value="">Select a G pub...</option>
                              {pubs.filter(p => p.firstLetter === 'G').sort((a, b) => a.name.localeCompare(b.name)).map((pub, idx) => (
                                <option key={idx} value={pub.name}>{pub.name}</option>
                              ))}
                            </select>
                          </div>
                        </div>
                        <p className="text-xs text-gray-400">
                          {startingPub 
                            ? `Routes will start from ${startingPub.name} and head towards Oval` 
                            : startingArea !== 'any' 
                              ? `Routes will start from ${startingArea} area and head towards Oval`
                              : 'Routes will consider all possible starting points'}
                        </p>
                      </div>

                      <div className="mb-6 p-4 bg-gray-700 rounded-lg border border-gray-600">
                        <h3 className="font-semibold text-amber-400 mb-3">Letters needed for "GLYPH & GOOSE":</h3>
                        <div className="flex flex-wrap gap-3">
                          {targetLetters.map((letter, idx) => {
                            const count = letterCounts[letter] || 0;
                            const needed = targetLetters.filter(l => l === letter).length;
                            return (
                              <div key={idx} className={`px-3 py-2 rounded ${count >= needed ? 'bg-green-900 border-green-600' : 'bg-red-900 border-red-600'} border`}>
                                <span className="font-bold text-lg text-gray-100">{letter}</span>
                                <span className="text-sm ml-2 text-gray-300">({count} found, {needed} needed)</span>
                              </div>
                            );
                          })}
                        </div>
                      </div>

                      <div className="mb-6">
                        <button 
                          onClick={calculateOptimalRoutes}
                          className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition flex items-center gap-2 font-semibold"
                        >
                          <ZapIcon />
                          Generate Optimal Routes
                        </button>
                        
                        {statusMessage && (
                          <div className={`mt-4 p-3 rounded ${statusMessage.includes('ERROR') ? 'bg-red-900 border border-red-600' : 'bg-blue-900 border border-blue-600'}`}>
                            <p className="text-sm text-gray-100">{statusMessage}</p>
                          </div>
                        )}
                        
                        {debugLog.length > 0 && (
                          <div className="mt-4 p-3 rounded bg-gray-900 border border-gray-600 max-h-60 overflow-y-auto">
                            <p className="text-xs font-bold text-amber-400 mb-2">Debug Log:</p>
                            {debugLog.map((log, idx) => (
                              <p key={idx} className="text-xs text-gray-300 font-mono">{log}</p>
                            ))}
                          </div>
                        )}
                      </div>

                      {routes.length > 0 && (
                        <div className="mb-8">
                          <h2 className="text-2xl font-bold text-amber-400 mb-4 flex items-center gap-2">
                            <NavigationIcon />
                            Top {routes.length} Routes
                            {startingPub && <span className="text-sm text-gray-400">(from {startingPub.name})</span>}
                            {!startingPub && startingArea !== 'any' && <span className="text-sm text-gray-400">(from {startingArea})</span>}
                          </h2>
                          {routes.map((route, idx) => (
                            <div key={idx} className="mb-6 p-4 bg-gray-700 border-2 border-green-600 rounded-lg">
                              <div className="flex justify-between items-center mb-3">
                                <div>
                                  <h3 className="text-xl font-semibold text-green-400">
                                    Route {idx + 1} - {route.totalDistance.toFixed(2)} km ({(route.totalDistance * 0.621371).toFixed(2)} mi)
                                  </h3>
                                  <p className="text-sm text-gray-300 mt-1">
                                    üìç {route.startPubName} ‚Üí {route.endPubName}
                                  </p>
                                  <p className="text-xs text-green-300 mt-1">
                                    Ending {route.distanceToHome.toFixed(2)} km from Oval
                                  </p>
                                </div>
                                <div className="flex gap-2">
                                  <button 
                                    onClick={() => openInGoogleMaps(route)}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition flex items-center gap-2 text-sm"
                                  >
                                    <MapPinIcon />
                                    Open in Maps
                                  </button>
                                  <button 
                                    onClick={() => downloadRouteCSV(route, idx)}
                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition flex items-center gap-2 text-sm"
                                  >
                                    <DownloadIcon />
                                    Download CSV
                                  </button>
                                </div>
                              </div>
                              <div className="space-y-2">
                                {route.route.map((stop, stopIdx) => (
                                  <div key={stopIdx} className="flex items-center gap-3 p-2 bg-gray-800 rounded border border-gray-600">
                                    <div className="flex-shrink-0 w-8 h-8 bg-green-600 text-white rounded-full flex items-center justify-center font-bold text-sm">
                                      {stopIdx + 1}
                                    </div>
                                    <div className="flex-shrink-0 w-8 h-8 bg-amber-500 text-white rounded flex items-center justify-center font-bold">
                                      {stop.letter}
                                    </div>
                                    <div className="flex-grow">
                                      <div className="font-semibold text-gray-100">{stop.pub.name}</div>
                                      <div className="text-sm text-gray-400">{stop.pub.address}</div>
                                    </div>
                                    {stopIdx > 0 && (
                                      <div className="text-sm text-green-400 font-mono">
                                        +{stop.distance.toFixed(2)} km
                                      </div>
                                    )}
                                    {stopIdx === route.route.length - 1 && (
                                      <div className="text-xs text-blue-400">
                                        üè† Closest to Oval
                                      </div>
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}

                      <div className="flex gap-4 mb-6 flex-wrap">
                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-1">Filter by Letter:</label>
                          <select 
                            value={filterLetter} 
                            onChange={(e) => setFilterLetter(e.target.value)}
                            className="px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-100"
                          >
                            <option value="all">All Letters</option>
                            {['G', 'L', 'Y', 'P', 'H', 'O', 'S', 'E'].map(letter => (
                              <option key={letter} value={letter}>{letter} ({letterCounts[letter] || 0})</option>
                            ))}
                          </select>
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-1">Sort by:</label>
                          <select 
                            value={sortBy} 
                            onChange={(e) => setSortBy(e.target.value)}
                            className="px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-100"
                          >
                            <option value="letter">Letter</option>
                            <option value="name">Name</option>
                          </select>
                        </div>

                        <div className="ml-auto">
                          <label className="block text-sm font-medium text-gray-300 mb-1">&nbsp;</label>
                          <button 
                            onClick={downloadCSV}
                            className="px-6 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition flex items-center gap-2"
                          >
                            <DownloadIcon />
                            Download All Pubs CSV
                          </button>
                        </div>
                      </div>

                      <div className="overflow-x-auto rounded-lg border border-gray-700">
                        <table className="w-full border-collapse">
                          <thead>
                            <tr className="bg-gray-700">
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Letter</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Pub Name</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Latitude</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Longitude</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Address</th>
                            </tr>
                          </thead>
                          <tbody>
                            {sortedPubs.map((pub, idx) => (
                              <tr key={idx} className="hover:bg-gray-700 transition">
                                <td className="border border-gray-600 px-4 py-2 font-bold text-amber-500">{pub.firstLetter}</td>
                                <td className="border border-gray-600 px-4 py-2 text-gray-200">{pub.name}</td>
                                <td className="border border-gray-600 px-4 py-2 font-mono text-sm text-gray-300">{pub.lat}</td>
                                <td className="border border-gray-600 px-4 py-2 font-mono text-sm text-gray-300">{pub.lon}</td>
                                <td className="border border-gray-600 px-4 py-2 text-sm text-gray-400">{pub.address}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>

                      <p className="mt-4 text-gray-400 text-sm">Total pubs found: {sortedPubs.length}</p>
                    </>
                  )}

                  {pubs.length === 0 && (
                    <div className="text-center py-12 text-gray-500">
                      <MapPinIcon />
                      <p className="mt-4">Upload a GeoJSON file to get started!</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<PubCrawlPlanner />, document.getElementById('root'));
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLYPH & GOOSE Pub Crawl Planner</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState } = React;

        function PubCrawlPlanner() {
          const [pubs, setPubs] = useState([]);
          const [sortBy, setSortBy] = useState('letter');
          const [filterLetter, setFilterLetter] = useState('all');
          const [routes, setRoutes] = useState([]);
          const [statusMessage, setStatusMessage] = useState('');
          const [debugLog, setDebugLog] = useState([]);
          const [homeLocation, setHomeLocation] = useState({ lat: 51.4817, lon: -0.1130 });
          const [startingArea, setStartingArea] = useState('any');
          const [startingPub, setStartingPub] = useState(null);

          const getFirstLetter = (name) => {
            const cleanName = name.replace(/^the\s+/i, '');
            return cleanName.charAt(0).toUpperCase();
          };

          const processGeoJSON = (geojson) => {
            const features = geojson.features || [];
            const processed = [];

            features.forEach(feature => {
              const props = feature.properties || {};
              const geometry = feature.geometry;
              
              if (props.amenity === 'pub' && props.name && geometry) {
                const firstLetter = getFirstLetter(props.name);
                
                if (['G', 'L', 'Y', 'P', 'H', 'O', 'S', 'E'].includes(firstLetter)) {
                  let lat, lon;
                  
                  if (geometry.type === 'Point') {
                    lon = geometry.coordinates[0];
                    lat = geometry.coordinates[1];
                  } else if (geometry.type === 'Polygon' || geometry.type === 'LineString') {
                    const coords = geometry.type === 'Polygon' ? geometry.coordinates[0] : geometry.coordinates;
                    let sumLat = 0, sumLon = 0;
                    coords.forEach(coord => {
                      sumLon += coord[0];
                      sumLat += coord[1];
                    });
                    lon = sumLon / coords.length;
                    lat = sumLat / coords.length;
                  } else {
                    return;
                  }
                  
                  if (lat != null && lon != null && !isNaN(lat) && !isNaN(lon)) {
                    processed.push({
                      name: props.name,
                      firstLetter: firstLetter,
                      lat: lat,
                      lon: lon,
                      address: props['addr:street'] || 'N/A',
                      city: props['addr:city'] || 'N/A'
                    });
                  }
                }
              }
            });

            return processed;
          };

          const handleFileUpload = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const geojson = JSON.parse(e.target.result);
                const processed = processGeoJSON(geojson);
                setPubs(processed);
                setRoutes([]);
                setStatusMessage(`Loaded ${processed.length} pubs`);
                setDebugLog([]);
              } catch (error) {
                alert('Error parsing GeoJSON file: ' + error.message);
              }
            };
            reader.readAsText(file);
          };

          const calculateDistance = (lat1, lon1, lat2, lon2) => {
            if (lat1 == null || lon1 == null || lat2 == null || lon2 == null) {
              return NaN;
            }
            if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || 
                typeof lat2 !== 'number' || typeof lon2 !== 'number') {
              return NaN;
            }
            
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
              Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
          };

          const generateRouteForward = (startPub, endPub, allPubs, variation = 0) => {
            const sequence = ['G', 'L', 'Y', 'P', 'H', 'G', 'O', 'O', 'S', 'E'];
            const route = [{ pub: startPub, distance: 0, letter: 'G' }];
            const usedPubIds = new Set([startPub.name + startPub.lat]);
            
            let currentLat = startPub.lat;
            let currentLon = startPub.lon;
            let totalDistance = 0;

            for (let i = 1; i < sequence.length; i++) {
              const targetLetter = sequence[i];
              
              if (i === sequence.length - 1) {
                const finalDist = calculateDistance(currentLat, currentLon, endPub.lat, endPub.lon);
                route.push({
                  pub: endPub,
                  distance: finalDist,
                  letter: 'E'
                });
                totalDistance += finalDist;
                break;
              }
              
              const candidates = allPubs.filter(p => 
                p.firstLetter === targetLetter && 
                !usedPubIds.has(p.name + p.lat) &&
                p.lat != null &&
                p.lon != null
              );
              
              if (candidates.length === 0) return null;
              
              const scoredCandidates = [];
              
              for (const pub of candidates) {
                const pubLat = typeof pub.lat === 'number' ? pub.lat : parseFloat(pub.lat);
                const pubLon = typeof pub.lon === 'number' ? pub.lon : parseFloat(pub.lon);
                
                if (isNaN(pubLat) || isNaN(pubLon)) continue;
                
                const distFromCurrent = calculateDistance(currentLat, currentLon, pubLat, pubLon);
                const distToEnd = calculateDistance(pubLat, pubLon, endPub.lat, endPub.lon);
                
                if (isNaN(distFromCurrent) || isNaN(distToEnd)) continue;
                
                let score;
                
                if (i === sequence.length - 2) {
                  if (distToEnd > 1.0) {
                    const penalty = (distToEnd - 1.0) * 5;
                    score = (distFromCurrent * 0.3) + (distToEnd * 0.7) + penalty;
                  } else {
                    score = (distFromCurrent * 0.4) + (distToEnd * 0.6);
                  }
                } else {
                  const progressWeight = 0.3 + (i / sequence.length * 0.3);
                  const nearWeight = 1 - progressWeight;
                  score = (distFromCurrent * nearWeight) + (distToEnd * progressWeight);
                }
                
                scoredCandidates.push({ pub, score });
              }
              
              if (scoredCandidates.length === 0) return null;
              
              scoredCandidates.sort((a, b) => a.score - b.score);
              
              let selectedPub;
              if (variation === 0) {
                selectedPub = scoredCandidates[0].pub;
              } else {
                const topN = Math.min(5, scoredCandidates.length);
                const index = (variation - 1) % topN;
                selectedPub = scoredCandidates[index].pub;
              }
              
              const stepDist = calculateDistance(currentLat, currentLon, selectedPub.lat, selectedPub.lon);
              
              route.push({
                pub: selectedPub,
                distance: stepDist,
                letter: targetLetter
              });
              
              usedPubIds.add(selectedPub.name + selectedPub.lat);
              currentLat = selectedPub.lat;
              currentLon = selectedPub.lon;
              totalDistance += stepDist;
            }

            return { route, totalDistance };
          };

          const calculateOptimalRoutes = () => {
            try {
              setStatusMessage('Starting calculation...');
              setDebugLog([]);
              
              const ePubs = pubs.filter(p => p.firstLetter === 'E');
              
              if (ePubs.length === 0) {
                setStatusMessage('ERROR: No pubs starting with E found!');
                return;
              }
              
              ePubs.sort((a, b) => {
                const distA = calculateDistance(a.lat, a.lon, homeLocation.lat, homeLocation.lon);
                const distB = calculateDistance(b.lat, b.lon, homeLocation.lat, homeLocation.lon);
                return distA - distB;
              });
              
              const closestEPub = ePubs[0];
              const closestEDist = calculateDistance(closestEPub.lat, closestEPub.lon, homeLocation.lat, homeLocation.lon);
              
              setStatusMessage(`Found ${ePubs.length} E pubs. Using closest to Oval as endpoint...`);
              setDebugLog([
                `Closest E pub to Oval: ${closestEPub.name} (${closestEDist.toFixed(2)}km away)`,
                `All routes will end at this pub`
              ]);
              
              const letterCounts = {};
              pubs.forEach(p => {
                letterCounts[p.firstLetter] = (letterCounts[p.firstLetter] || 0) + 1;
              });
              
              const needed = { G: 2, L: 1, Y: 1, P: 1, H: 1, O: 2, S: 1, E: 1 };
              const missing = [];
              for (const [letter, count] of Object.entries(needed)) {
                if (!letterCounts[letter] || letterCounts[letter] < count) {
                  missing.push(`${letter} (need ${count}, have ${letterCounts[letter] || 0})`);
                }
              }
              
              if (missing.length > 0) {
                setStatusMessage(`ERROR: Missing letters: ${missing.join(', ')}`);
                return;
              }
              
              let gPubs = pubs.filter(p => p.firstLetter === 'G');
              
              if (startingPub) {
                gPubs = [startingPub];
                setStatusMessage(`Finding routes from ${startingPub.name} to ${closestEPub.name}...`);
                setDebugLog(prev => [...prev, `Generating multiple route variations from ${startingPub.name}...`]);
              } else if (startingArea !== 'any') {
                const areaCoords = {
                  soho: { lat: 51.5136, lon: -0.1358 },
                  coventGarden: { lat: 51.5117, lon: -0.1232 },
                  shoreditch: { lat: 51.5251, lon: -0.0823 },
                  camden: { lat: 51.5392, lon: -0.1426 },
                  southBank: { lat: 51.5074, lon: -0.1198 }
                };
                
                const areaCenter = areaCoords[startingArea];
                if (areaCenter) {
                  gPubs = gPubs.filter(g => {
                    const dist = calculateDistance(g.lat, g.lon, areaCenter.lat, areaCenter.lon);
                    return dist <= 1.5;
                  }).sort((a, b) => {
                    const distA = calculateDistance(a.lat, a.lon, areaCenter.lat, areaCenter.lon);
                    const distB = calculateDistance(b.lat, b.lon, areaCenter.lat, areaCenter.lon);
                    return distA - distB;
                  });
                  
                  setStatusMessage(`Finding routes from ${startingArea} to ${closestEPub.name}...`);
                  setDebugLog(prev => [...prev, `Found ${gPubs.length} G pubs in ${startingArea}`]);
                }
              } else {
                setStatusMessage(`Finding best routes ending at ${closestEPub.name}...`);
              }
              
              if (gPubs.length === 0) {
                setStatusMessage('ERROR: No suitable starting pubs found in selected area!');
                return;
              }
              
              const allRoutes = [];
              const maxToTest = startingPub ? 1 : Math.min(30, gPubs.length);
              
              setDebugLog(prev => [...prev, `Testing ${maxToTest} starting points (routes will move towards Oval)...`]);
              
              if (startingPub) {
                for (let v = 0; v < 20; v++) {
                  const route = generateRouteForward(startingPub, closestEPub, pubs, v);
                  if (route) {
                    route.distanceToHome = closestEDist;
                    route.endPubName = closestEPub.name;
                    route.startPubName = startingPub.name;
                    route.variation = v;
                    allRoutes.push(route);
                  }
                }
                setDebugLog(prev => [...prev, `Generated ${allRoutes.length} different routes from ${startingPub.name}`]);
              } else {
                for (let i = 0; i < maxToTest; i++) {
                  const route = generateRouteForward(gPubs[i], closestEPub, pubs, 0);
                  if (route) {
                    route.distanceToHome = closestEDist;
                    route.endPubName = closestEPub.name;
                    route.startPubName = gPubs[i].name;
                    allRoutes.push(route);
                  }
                  
                  if (i % 10 === 0 && i > 0) {
                    setDebugLog(prev => [...prev, `Processed ${i} starting points, found ${allRoutes.length} routes...`]);
                  }
                }
              }
              
              if (allRoutes.length === 0) {
                setStatusMessage('ERROR: Could not generate any valid routes!');
                return;
              }
              
              allRoutes.sort((a, b) => a.totalDistance - b.totalDistance);
              
              const topRoutes = allRoutes.slice(0, 10);
              setRoutes(topRoutes);
              
              setDebugLog(prev => [...prev, 
                `‚úÖ Complete! All routes end at ${closestEPub.name} (${closestEDist.toFixed(2)}km from Oval)`,
                `Shortest route: ${topRoutes[0].totalDistance.toFixed(2)}km from ${topRoutes[0].startPubName}`
              ]);
              setStatusMessage(`SUCCESS! Top ${topRoutes.length} routes, all ending at ${closestEPub.name}.`);
            } catch (error) {
              setStatusMessage(`ERROR: ${error.message}`);
              setDebugLog(prev => [...prev, `Exception: ${error.message}`]);
            }
          };

          const getSortedPubs = () => {
            let filtered = filterLetter === 'all' 
              ? pubs 
              : pubs.filter(p => p.firstLetter === filterLetter);

            return [...filtered].sort((a, b) => {
              if (sortBy === 'letter') {
                return a.firstLetter.localeCompare(b.firstLetter) || a.name.localeCompare(b.name);
              } else {
                return a.name.localeCompare(b.name);
              }
            });
          };

          const downloadCSV = () => {
            const sorted = getSortedPubs();
            const headers = ['Pub Name', 'First Letter', 'Latitude', 'Longitude', 'Address', 'City'];
            const rows = sorted.map(pub => [
              `"${pub.name}"`,
              pub.firstLetter,
              pub.lat,
              pub.lon,
              `"${pub.address}"`,
              `"${pub.city}"`
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pub-crawl-data.csv';
            a.click();
            window.URL.revokeObjectURL(url);
          };

          const downloadRouteCSV = (route, routeIndex) => {
            const headers = ['Stop', 'Letter', 'Pub Name', 'Distance from Previous (km)', 'Latitude', 'Longitude', 'Address'];
            const rows = route.route.map((stop, idx) => [
              idx + 1,
              stop.letter,
              `"${stop.pub.name}"`,
              stop.distance.toFixed(2),
              stop.pub.lat,
              stop.pub.lon,
              `"${stop.pub.address}"`
            ]);

            const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route-${routeIndex + 1}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
          };

          const openInGoogleMaps = (route) => {
            const stops = route.route.map(stop => 
              `${stop.pub.lat},${stop.pub.lon}`
            );
            
            if (stops.length > 10) {
              alert(`Google Maps supports a maximum of 10 stops. This route has ${stops.length} stops. Opening first 10 stops only.`);
            }
            
            const limitedStops = stops.slice(0, 10);
            const mapsUrl = `https://www.google.com/maps/dir/${limitedStops.join('/')}`;
            window.open(mapsUrl, '_blank');
          };

          const getLetterCounts = () => {
            const counts = {};
            pubs.forEach(pub => {
              counts[pub.firstLetter] = (counts[pub.firstLetter] || 0) + 1;
            });
            return counts;
          };

          const letterCounts = getLetterCounts();
          const sortedPubs = getSortedPubs();
          const targetLetters = ['G', 'L', 'Y', 'P', 'H', 'G', 'O', 'O', 'S', 'E'];

          // Lucide React icons as SVG
          const MapPinIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
          );

          const UploadIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="17 8 12 3 7 8"></polyline>
              <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
          );

          const ZapIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
            </svg>
          );

          const NavigationIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>
            </svg>
          );

          const DownloadIcon = () => (
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
          );

          return (
            <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-8">
              <div className="max-w-6xl mx-auto">
                <div className="bg-gray-800 rounded-lg shadow-2xl p-8 border border-gray-700">
                  <h1 className="text-3xl font-bold text-amber-400 mb-2 flex items-center gap-2">
                    <MapPinIcon />
                    GLYPH & GOOSE Pub Crawl Planner
                  </h1>
                  <p className="text-gray-400 mb-6">Upload your pub data to plan your optimal pub crawl route</p>

                  <div className="mb-6">
                    <label className="flex items-center justify-center w-full px-4 py-6 bg-gray-700 border-2 border-dashed border-amber-600 rounded-lg cursor-pointer hover:bg-gray-600 transition">
                      <UploadIcon />
                      <span className="text-amber-400 font-medium ml-2">Upload GeoJSON File</span>
                      <input type="file" accept=".json,.geojson" onChange={handleFileUpload} className="hidden" />
                    </label>
                  </div>

                  {pubs.length > 0 && (
                    <>
                      <div className="mb-6 p-4 bg-gray-700 rounded-lg border border-gray-600">
                        <h3 className="font-semibold text-amber-400 mb-3">Starting Location Options:</h3>
                        <div className="grid grid-cols-2 gap-4 mb-4">
                          <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Choose Starting Area:</label>
                            <select 
                              value={startingArea} 
                              onChange={(e) => {
                                setStartingArea(e.target.value);
                                setStartingPub(null);
                              }}
                              className="w-full px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg text-gray-100"
                            >
                              <option value="any">Any Location</option>
                              <option value="soho">Soho</option>
                              <option value="coventGarden">Covent Garden</option>
                              <option value="shoreditch">Shoreditch</option>
                              <option value="camden">Camden</option>
                              <option value="southBank">South Bank</option>
                            </select>
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium text-gray-300 mb-2">Or Pick Specific Pub:</label>
                            <select 
                              value={startingPub ? startingPub.name : ''} 
                              onChange={(e) => {
                                const pub = pubs.find(p => p.name === e.target.value && p.firstLetter === 'G');
                                setStartingPub(pub || null);
                                if (pub) setStartingArea('any');
                              }}
                              className="w-full px-4 py-2 bg-gray-800 border border-gray-600 rounded-lg text-gray-100"
                            >
                              <option value="">Select a G pub...</option>
                              {pubs.filter(p => p.firstLetter === 'G').sort((a, b) => a.name.localeCompare(b.name)).map((pub, idx) => (
                                <option key={idx} value={pub.name}>{pub.name}</option>
                              ))}
                            </select>
                          </div>
                        </div>
                        <p className="text-xs text-gray-400">
                          {startingPub 
                            ? `Routes will start from ${startingPub.name} and head towards Oval` 
                            : startingArea !== 'any' 
                              ? `Routes will start from ${startingArea} area and head towards Oval`
                              : 'Routes will consider all possible starting points'}
                        </p>
                      </div>

                      <div className="mb-6 p-4 bg-gray-700 rounded-lg border border-gray-600">
                        <h3 className="font-semibold text-amber-400 mb-3">Letters needed for "GLYPH & GOOSE":</h3>
                        <div className="flex flex-wrap gap-3">
                          {targetLetters.map((letter, idx) => {
                            const count = letterCounts[letter] || 0;
                            const needed = targetLetters.filter(l => l === letter).length;
                            return (
                              <div key={idx} className={`px-3 py-2 rounded ${count >= needed ? 'bg-green-900 border-green-600' : 'bg-red-900 border-red-600'} border`}>
                                <span className="font-bold text-lg text-gray-100">{letter}</span>
                                <span className="text-sm ml-2 text-gray-300">({count} found, {needed} needed)</span>
                              </div>
                            );
                          })}
                        </div>
                      </div>

                      <div className="mb-6">
                        <button 
                          onClick={calculateOptimalRoutes}
                          className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition flex items-center gap-2 font-semibold"
                        >
                          <ZapIcon />
                          Generate Optimal Routes
                        </button>
                        
                        {statusMessage && (
                          <div className={`mt-4 p-3 rounded ${statusMessage.includes('ERROR') ? 'bg-red-900 border border-red-600' : 'bg-blue-900 border border-blue-600'}`}>
                            <p className="text-sm text-gray-100">{statusMessage}</p>
                          </div>
                        )}
                        
                        {debugLog.length > 0 && (
                          <div className="mt-4 p-3 rounded bg-gray-900 border border-gray-600 max-h-60 overflow-y-auto">
                            <p className="text-xs font-bold text-amber-400 mb-2">Debug Log:</p>
                            {debugLog.map((log, idx) => (
                              <p key={idx} className="text-xs text-gray-300 font-mono">{log}</p>
                            ))}
                          </div>
                        )}
                      </div>

                      {routes.length > 0 && (
                        <div className="mb-8">
                          <h2 className="text-2xl font-bold text-amber-400 mb-4 flex items-center gap-2">
                            <NavigationIcon />
                            Top {routes.length} Routes
                            {startingPub && <span className="text-sm text-gray-400">(from {startingPub.name})</span>}
                            {!startingPub && startingArea !== 'any' && <span className="text-sm text-gray-400">(from {startingArea})</span>}
                          </h2>
                          {routes.map((route, idx) => (
                            <div key={idx} className="mb-6 p-4 bg-gray-700 border-2 border-green-600 rounded-lg">
                              <div className="flex justify-between items-center mb-3">
                                <div>
                                  <h3 className="text-xl font-semibold text-green-400">
                                    Route {idx + 1} - {route.totalDistance.toFixed(2)} km ({(route.totalDistance * 0.621371).toFixed(2)} mi)
                                  </h3>
                                  <p className="text-sm text-gray-300 mt-1">
                                    üìç {route.startPubName} ‚Üí {route.endPubName}
                                  </p>
                                  <p className="text-xs text-green-300 mt-1">
                                    Ending {route.distanceToHome.toFixed(2)} km from Oval
                                  </p>
                                </div>
                                <div className="flex gap-2">
                                  <button 
                                    onClick={() => openInGoogleMaps(route)}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition flex items-center gap-2 text-sm"
                                  >
                                    <MapPinIcon />
                                    Open in Maps
                                  </button>
                                  <button 
                                    onClick={() => downloadRouteCSV(route, idx)}
                                    className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition flex items-center gap-2 text-sm"
                                  >
                                    <DownloadIcon />
                                    Download CSV
                                  </button>
                                </div>
                              </div>
                              <div className="space-y-2">
                                {route.route.map((stop, stopIdx) => (
                                  <div key={stopIdx} className="flex items-center gap-3 p-2 bg-gray-800 rounded border border-gray-600">
                                    <div className="flex-shrink-0 w-8 h-8 bg-green-600 text-white rounded-full flex items-center justify-center font-bold text-sm">
                                      {stopIdx + 1}
                                    </div>
                                    <div className="flex-shrink-0 w-8 h-8 bg-amber-500 text-white rounded flex items-center justify-center font-bold">
                                      {stop.letter}
                                    </div>
                                    <div className="flex-grow">
                                      <div className="font-semibold text-gray-100">{stop.pub.name}</div>
                                      <div className="text-sm text-gray-400">{stop.pub.address}</div>
                                    </div>
                                    {stopIdx > 0 && (
                                      <div className="text-sm text-green-400 font-mono">
                                        +{stop.distance.toFixed(2)} km
                                      </div>
                                    )}
                                    {stopIdx === route.route.length - 1 && (
                                      <div className="text-xs text-blue-400">
                                        üè† Closest to Oval
                                      </div>
                                    )}
                                  </div>
                                ))}
                              </div>
                            </div>
                          ))}
                        </div>
                      )}

                      <div className="flex gap-4 mb-6 flex-wrap">
                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-1">Filter by Letter:</label>
                          <select 
                            value={filterLetter} 
                            onChange={(e) => setFilterLetter(e.target.value)}
                            className="px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-100"
                          >
                            <option value="all">All Letters</option>
                            {['G', 'L', 'Y', 'P', 'H', 'O', 'S', 'E'].map(letter => (
                              <option key={letter} value={letter}>{letter} ({letterCounts[letter] || 0})</option>
                            ))}
                          </select>
                        </div>

                        <div>
                          <label className="block text-sm font-medium text-gray-300 mb-1">Sort by:</label>
                          <select 
                            value={sortBy} 
                            onChange={(e) => setSortBy(e.target.value)}
                            className="px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-gray-100"
                          >
                            <option value="letter">Letter</option>
                            <option value="name">Name</option>
                          </select>
                        </div>

                        <div className="ml-auto">
                          <label className="block text-sm font-medium text-gray-300 mb-1">&nbsp;</label>
                          <button 
                            onClick={downloadCSV}
                            className="px-6 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-700 transition flex items-center gap-2"
                          >
                            <DownloadIcon />
                            Download All Pubs CSV
                          </button>
                        </div>
                      </div>

                      <div className="overflow-x-auto rounded-lg border border-gray-700">
                        <table className="w-full border-collapse">
                          <thead>
                            <tr className="bg-gray-700">
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Letter</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Pub Name</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Latitude</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Longitude</th>
                              <th className="border border-gray-600 px-4 py-2 text-left text-amber-400">Address</th>
                            </tr>
                          </thead>
                          <tbody>
                            {sortedPubs.map((pub, idx) => (
                              <tr key={idx} className="hover:bg-gray-700 transition">
                                <td className="border border-gray-600 px-4 py-2 font-bold text-amber-500">{pub.firstLetter}</td>
                                <td className="border border-gray-600 px-4 py-2 text-gray-200">{pub.name}</td>
                                <td className="border border-gray-600 px-4 py-2 font-mono text-sm text-gray-300">{pub.lat}</td>
                                <td className="border border-gray-600 px-4 py-2 font-mono text-sm text-gray-300">{pub.lon}</td>
                                <td className="border border-gray-600 px-4 py-2 text-sm text-gray-400">{pub.address}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>

                      <p className="mt-4 text-gray-400 text-sm">Total pubs found: {sortedPubs.length}</p>
                    </>
                  )}

                  {pubs.length === 0 && (
                    <div className="text-center py-12 text-gray-500">
                      <MapPinIcon />
                      <p className="mt-4">Upload a GeoJSON file to get started!</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<PubCrawlPlanner />, document.getElementById('root'));
    </script>
</body>
</html>
